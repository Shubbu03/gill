---
title: Working with signers
description: Create, import, and use keypair signers for Solana signing operations.
---

For most typical Solana transaction signing operations, you will be utilizing a `TransactionSigner`.
This object type is capable of being "attached" to instructions and transaction to perform signing
operations.

The most common of which is a `KeyPairSigner`, which is able to be passed around to the various
functions within gill to satisfies any `TransactionSigner` type requirements, like when building
instructions or creating transactions.

<Callout>
  Unless otherwise specifically noted in the gill documentation, the term "signer" refers to
  `TransactionSigner` and usually a `KeyPairSigner`.
</Callout>

## Generating a keypair signer

For various Solana development tasks, you may need to generate a new signer. Including when creating
a new account, generating reference keys for transactions, or
[creating tokens](/docs/guides/tokens/create-token).

The `generateKeyPairSigner()` function allows you to generate a new random `KeyPairSigner` (which
satisfies the `TransactionSigner` type) to perform signing operations.

```typescript twoslash
import { generateKeyPairSigner, type KeyPairSigner } from "gill";

const signer = await generateKeyPairSigner();
```

### Non-extractable by default

Under the hood, a `KeyPairSigner` utilize the
[Web Crypto APIs](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) to improve
security.

These signers are non-extractable by default; meaning there is no way to get the secret key material
out of the instance. This is a more secure practice and highly recommended to be used over
extractable keypairs, unless you REALLY need to be able to save the keypair for some reason.

## Generating extractable keypairs and signers

Extractable keypairs are less secure and should not be used unless you REALLY need to save the key
for some reason. Since there are a few useful cases for saving these keypairs, gill contains a
separate explicit function to generate these extractable keypairs.

To generate a random, **extractable** `KeyPairSigner`:

```typescript twoslash
import { generateExtractableKeyPairSigner } from "gill";

const signer = await generateExtractableKeyPairSigner();
```

<Callout title="WARNING" type="error">
  Using **extractable** keypairs are inherently less-secure, since they allow the secret key
  material to be extracted. Obviously. As such, they should only be used sparingly and ONLY when you
  have an explicit reason you need extract the key material (like if you are going to save the key
  to a file or environment variable).
</Callout>

## Create a signer without the secret key

If your Solana application allows users to sign transaction's by way of connecting their wallet
(e.g. Backpack, Phantom, Solflare, etc) to your app, you will not have access to their secret key
material.

You will need to create a "noop signer" in order to satisfy the `TransactionSigner` type, such as
the `createTransaction()` functions's `feePayer`:

```typescript twoslash
import { createNoopSigner, type Address, createTransaction } from "gill";

const wallet = "nick6zJc6HpW3kfBm4xS2dmbuVRyb5F3AnUvj5ymzR5" as Address;

const signer = createNoopSigner(wallet);

const transaction = createTransaction({
  version: "legacy",
  feePayer: signer,
  instructions: [],
});
```

## Import existing wallet keys

If you already have a wallet from popular wallet apps like Phantom, Solflare, or a Solana CLI keypair, you can easily import those keys to use with gill. Different wallets export keys in different formats, but gill provides functions to handle each format.

### From Phantom wallet (Base58 format)

Phantom wallet typically exports private keys as Base58-encoded strings. These are usually 88 characters long for a full keypair or 44 characters for just the private key.

```typescript twoslash
import { createKeypairSignerFromBase58 } from "gill";

// Example Base58 private key from Phantom
const phantomPrivateKey = "5JuEY8..."; // Your actual Base58 private key

const signer = await createKeypairSignerFromBase58(phantomPrivateKey);

console.log("Public key:", signer.address); // Base58 encoded public key
```

### From Solflare wallet (JSON byte array)

Solflare and Solana CLI export keypairs as JSON arrays containing byte values. This is the same format stored in `~/.config/solana/id.json`.

```typescript twoslash
import { loadKeypairSignerFromEnvironment } from "gill/node";

// For environment variables containing JSON byte arrays
// Example: PRIVATE_KEY="[123,45,67,89,...]"
const signer = await loadKeypairSignerFromEnvironment("PRIVATE_KEY");

console.log("Public key:", signer.address);
```

If you have the JSON string directly:

```typescript twoslash
import { createKeyPairSignerFromPrivateKeyBytes } from "gill";

// JSON byte array format (Solflare/CLI export)
const solflareKey = "[158,162,68,53,7,160,11,228,...]"; // Your keypair JSON
const byteArray = new Uint8Array(JSON.parse(solflareKey));

// Handle both 32-byte (private key only) and 64-byte (full keypair) formats
const privateKeyBytes = byteArray.length === 64 
  ? byteArray.slice(0, 32)  // Extract first 32 bytes (private key)
  : byteArray;              // Already 32 bytes

const signer = await createKeyPairSignerFromPrivateKeyBytes(privateKeyBytes);
```

### From Solana CLI keypair files

If you have a keypair file generated by `solana-keygen`, you can load it directly:

```typescript twoslash
import { loadKeypairSignerFromFile } from "gill/node";

// Load from default CLI location
const signer = await loadKeypairSignerFromFile();

// Or specify a custom path
const customSigner = await loadKeypairSignerFromFile("./my-keypair.json");
```

### From environment variables (Base58)

For Base58-encoded private keys stored in environment variables:

```typescript twoslash
import { loadKeypairSignerFromEnvironmentBase58 } from "gill/node";

// For environment variables containing Base58 private keys
// Example: PHANTOM_KEY="5JuEY8..."
const signer = await loadKeypairSignerFromEnvironmentBase58("PHANTOM_KEY");
```

### Manual format conversion

If you need to convert between formats or handle edge cases:

```typescript twoslash
import { createKeyPairSignerFromPrivateKeyBytes, getBase58Encoder } from "gill";

// Convert Base58 to bytes manually
const base58Key = "5JuEY8..."; // Your Base58 private key
const encoder = getBase58Encoder();
const decodedBytes = encoder.decode(base58Key);

// Handle different byte lengths
const privateKey = decodedBytes.length === 64 
  ? decodedBytes.slice(0, 32) 
  : decodedBytes;

const signer = await createKeyPairSignerFromPrivateKeyBytes(privateKey);
```

## Wallet key format reference

Different wallets and tools export private keys in various formats:

| Wallet/Tool | Format | Example | Length |
|-------------|--------|---------|---------|
| **Phantom** | Base58 string | `"5JuEY8..."` | 44 or 88 chars |
| **Solflare** | JSON byte array | `"[123,45,67,...]"` | 32 or 64 elements |
| **Solana CLI** | JSON file | `~/.config/solana/id.json` | 64 bytes |
| **Hardware** | Not exportable | - | - |

## Security considerations

<Callout title="SECURITY WARNING" type="error">
  **Never** expose private keys in frontend applications or commit them to version control. 
  Private keys should only be used in secure backend environments or development setups.
</Callout>

### For frontend applications

In frontend apps where users connect their wallets, you should **not** import private keys. Instead, use the wallet adapter pattern:

```typescript twoslash
import { createNoopSigner, type Address } from "gill";

// User's public key from connected wallet
const userWallet = "nick6zJc6HpW3kfBm4xS2dmbuVRyb5F3AnUvj5ymzR5" as Address;

// Create a noop signer for transaction building
const signer = createNoopSigner(userWallet);

// The actual signing happens in the user's wallet
```

### For backend/development

Private key import is appropriate for:
- Development and testing environments
- Backend services with secure key storage
- CLI tools and scripts
- Automated trading bots

Always store private keys in:
- Environment variables (never in code)
- Secure key management systems
- Encrypted storage solutions
